<!doctype HTML>
<html>
<script src="https://aframe.io/releases/0.9.2/aframe.min.js"></script>
<script src="https://raw.githack.com/jeromeetienne/AR.js/2.0.8/aframe/build/aframe-ar.js"></script>
<script src=â€https://rawgit.com/donmccurdy/aframe-extras/master/dist/aframe-extras.loaders.min.js"></script>
<script src="https://unpkg.com/aframe-particle-system-component@1.0.9/dist/aframe-particle-system-component.min.js"></script>
<!-- Firebase App (the core Firebase SDK) is always required and must be listed first -->
<script src="https://www.gstatic.com/firebasejs/7.5.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.5.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/7.5.0/firebase-firestore.js"></script>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<link type="text/css" rel="stylesheet" href="tree.css">
<script>

    let A_GREEN = '#3EEF2D';
    let A_RED = '#EF2D5E';
    let A_BLUE = '#3E2DEF';

    // Global variable of the number
    var currentNodeItems = "";
    var currentNodeItemsIntialized = false;
    var database;
    var sfDocRef;

    setupTouchHandling();

    // Check the tree loading and respond accordingly
    AFRAME.registerComponent('tree', {
        init: function () {
            // Wait for model to load.
            const el = this.el;
            this.el.addEventListener('model-loaded', function() {
                console.log("Loaded model");
                // alert("model loaded")
                // Grab the mesh / scene.
                setupFirebase();
                const obj = this.object3D;
                // Go over the submeshes and modify materials we want.
                obj.traverse(node => {
                    if (node.name.indexOf('Cone_') !== -1) {
                        node.material.color.set('#308529');
                        //node.geometry.computeFaceNormals(true);
                        //node.geometry.mergeVertices;
                        //node.geometry.computeVertexNormals(true);
                        //node.geometry.normalizeNormals();
                        node.material.flatShading = true;
                    }
                    if (node.name.indexOf('Bauble_') !== -1) {
                        //node.material = node.material.clone();
                        //node.geometry.computeFaceNormals();
                        // node.geometry.computeFaceNormals();

                        //node.geometry.mergeVertices;
                        //node.geometry.computeVertexNormals(false);
                        //node.geometry.normalizeNormals();
                        //node.geometry.normalsNeedUpdate = true;
                        //node.material.flatShading = false;
                        node.visible = false
                    }
                });
            });

            this.el.addEventListener('model-error', (e) => {
                alert(e)
            });
        }
    });

    function colorForLetter(letter) {
        switch (letter) {
            case 'r', 'R': return A_RED;
            case 'g', 'G': return A_GREEN;
            case 'b', 'B': return A_BLUE;
            default: return A_RED;
        }
    }

    function updateBaubles(allItems) {
        let sceneEl = document.querySelector('a-scene');
        let tree = sceneEl.querySelector('#tree-node');

        const obj = tree.object3D;

        if (allItems.length < currentNodeItems.length) {
            // Remove all Bauble objects and start again
            // Go over the submeshes and modify materials we want.
            var objToRemove = [];
            obj.traverse(node => {
                if (node.name.indexOf("Inserted_") != -1) {
                    console.log(`Deleting : ${node.name}`);
                    objToRemove.push(node);
                }
            });

            for (var node of objToRemove) {
                obj.remove(node);
                sceneEl.object3D.remove(node);
            }

            // Make it easier, just force a reset for now (Can optimize later)
            currentNodeItems = "";
        }

        let offset = currentNodeItems.length;
        let items = allItems.slice(offset);

        for (var i = 0; i < items.length; i++) {
            let baubleName = 'Bauble_' + (i + offset).toString();
            let color = colorForLetter(items.charAt(i));

            // Go over the submeshes and modify materials we want.
            obj.traverse(node => {
                if (node.name === baubleName) {
                    console.log(`Initialising : ${node.name}`);
                    placeSphere("Inserted_" + node.name, color, node.position)
                }
            });
        }

        currentNodeItemsIntialized = true;

        // Todo once we implement from the backend
        currentNodeItems = allItems;
    }

    function showCurrentBauble(color) {
        // If we haven't received anything then don't try to add items, this will overwrite everything
        if (currentNodeItemsIntialized === false) {
            return
        }

        // Pre-emptive
        updateBaubles(currentNodeItems + color);

        database.runTransaction(function(transaction) {
            return transaction.get(sfDocRef).then(function(sfDoc) {
                if (!sfDoc.exists) {
                    throw "Document does not exist!";
                }

                var newCount = sfDoc.data().currentNodeItems.length;
                if (newCount <= 1300) {
                    transaction.update(sfDocRef, { currentNodeItems: sfDoc.data().currentNodeItems + color });
                    return newCount;
                } else {
                    return Promise.reject("Cannot increment.");
                }
            });
        }).then(function(newCount) {
            console.log("Count increased to ", newCount);
        }).catch(function(err) {
            console.error(err);
        });
    }

    function placeSphere(nodeName, color, position) {
        let sceneEl = document.querySelector('a-scene');
        let markerEl = sceneEl.querySelector('#marker-node');
        let treeEl = sceneEl.querySelector('#tree-node');
        let el = document.createElement('a-sphere');

        let obj3d = el.object3D;
        obj3d.name = nodeName;

        el.setAttribute('position', position);
        el.setAttribute('radius', 0.05);
        el.setAttribute('color', color);

        treeEl.appendChild(el)
    }

    function setupFirebase() {
        // Setup access to the Google Firebase SDK
        var config = {
            apiKey: 'AIzaSyCmfCENTgiNO9_26ey1Pz2zzVLsvXxFONA',
            authDomain: 'arxmas-c90bf.firebaseapp.com',
            projectId: 'arxmas-c90bf',
        };

        firebase.initializeApp(config);

        database = firebase.firestore();

        firebase.auth().signInAnonymously().catch(function (error) {
            // Handle Errors here.
            var errorCode = error.code;
            var errorMessage = error.message;
            // ...
        });

        // Create a reference to the SF doc.
        sfDocRef = database.collection("current").doc("e68Wm7an4d2zpAiu8w2Z");

        firebase.auth().onAuthStateChanged(function (user) {
            if (user) {
                // User is signed in.
                var isAnonymous = user.isAnonymous;
                var uid = user.uid;
                // Listen for updates to the counter
                sfDocRef.onSnapshot(function (doc) {
                    console.log("Current data: ", doc.data());
                    updateBaubles(doc.data().currentNodeItems);//doc.data().currentNodeNameIndex);
                });
            } else {
                // User is signed out.
                // ...
            }
            // ...
        });
    }

    function setupTouchHandling() {
        // Manage Zoom and double tap handling
        window.addEventListener(
            "touchmove",
            function(event) {
                if (event.scale !== 1) {
                    event.preventDefault();
                }
            },
            { passive: false }
        );

        var lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            var now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
    }
</script>

<body>

<div id="info">
    <section>
    <button style='background-color: lightgreen' id="add_green" onclick="showCurrentBauble('G')">Add Green</button>
    <button style='background-color: lightblue' id="add_blue" onclick="showCurrentBauble('B')">Add Blue</button>
    <button style='background-color: indianred' id="add_red" onclick="showCurrentBauble('R')">Add Red</button>
    </section>
    <!--<label><input id="option_trs" name="trs" type="checkbox"/>TRS</label>
    <label><input id="option_visible" name="visible" type="checkbox" checked="checked"/>Only Visible</label>
    <label><input id="option_drawrange" name="visible" type="checkbox" checked="checked"/>Truncate drawRange</label><br/>
    <label><input id="option_binary" name="visible" type="checkbox">Binary (<code>.glb</code>)</label>
    <label><input id="option_forceindices" name="visible" type="checkbox">Force indices</label>
    <label><input id="option_forcepot" name="visible" type="checkbox">Force POT textures</label>
    <label><input id="option_maxsize" name="maxSize" type="number" value="4096" min="2" max="8192" step="1"> Max texture size</label>!-->
</div>
<!-- start the body of your page -->
<!-- add some info at the top of the page -->
<!--<a-scene embedded arjs='sourceType: webcam; detectionMode: mono; maxDetectionRate: 30; logarithmicDepthBuffer: true;' precision="low">-->
<a-scene embedded arjs="patternRatio: 0.75; sourceType: webcam; debugUIEnabled: false; " renderer='logarithmicDepthBuffer: false;' precision="low">
    <a-assets>
        <!--<a-asset-item id="cityModel" src="https://cdn.aframe.io/test-models/models/glTF-2.0/virtualcity/VC.gltf"></a-asset-item>-->
        <!--<a-asset-item id="skull" src="./scene.gltf"></a-asset-item>-->
        <a-asset-item id="tree" src="./tree_1300.gltf"></a-asset-item>
    </a-assets>

    <a-marker id="marker-node" type="pattern" url="/pattern-tree-75.patt">
<!--        <a-entity animation="property: rotation; to: 0 360 0; loop: true; dur: 1000" position="0 0.5 0" gltf-model="#tree" loading></a-entity>-->
        <a-entity id="tree-node" animation="property: rotation; to: 0 360; loop: true; dur: 10000; easing: linear" position="0 0.5 0" gltf-model="#tree" tree></a-entity>
        <a-entity particle-system="preset: snow; particleCount: 10000;" position="0 2.25 -15"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="20 10 10"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="20 10 -10"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="20 -10 -10"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="20 0 0"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="10 10 10"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="0 20 0"></a-entity>
        <a-entity light="type: point; intensity: 0.75; distance: 50"
                  position="0 -20 0"></a-entity>
    </a-marker>

    <a-entity id="size" position="0.0 -1.0 -5"
              text="color: white; align: center; value: On the first day of christmas my true love sent to me... a partridge in a pear tree!; width: 2">
    </a-entity>
    <a-entity camera></a-entity>
</a-scene>

</body>
</html>

